<!DOCTYPE html>
<!--[if lt IE 7]>
<html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>
<html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>
<html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js"> <!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://fonts.googleapis.com/css?family=Merriweather:300,700,300italic,700italic" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/normalize.min.css">
    <link rel="stylesheet" href="../css/main.css">


    <script src="../js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
</head>
<body>
<!--[if lt IE 7]>
<p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade
    your browser</a> to improve your experience.</p>
<![endif]-->


<div class="main-container">
    <div class="main wrapper clearfix">

        <article>
            <header>
                <h1>Turn an ice-cream cone into a pyramid</h1>

                <div class="publish-date">December 21, 2014</div>
                <div class="author">Written by <a href="http://twitter.com/BeniVF">Benigno Villa Fernández</a></div>
                <p>
                    One of the problems I have seen and shared with most of my colleagues is the application of <i>TDD/BDD</i>
                    in a real life scenario. Most of the time, you have to modify/maintain a system that contains a lot
                    of <em>integration tests</em>, <em>automated GUI tests</em> or <em>manual tests</em>. This situation
                    could lead to an <b>ice-cream
                    cone anti-pattern</b> as illustrated below.
                </p>
                <figure class="post_image"><img alt="" src="../img/icecreamconeantipattern.png" width="304"></figure>
            </header>
            <section>
                <h2>Ice-cream cone</h2>

                <p>
                    From a developer’s perspective, this situation is painful as it is often time consuming. For
                    example, when you want to add a new feature to the system, ensuring that this addition does not
                    break anything takes time. Furthermore, this time wasting severely disrupts the <i>TDD</i> system
                    flow. Having a lot of <em>integration tests</em> or <em>end-to-end tests</em> makes your suite tests
                    more <em>brittle</em>. In general, this can lead to false negative errors. Generally, these errors are
                    generated by the test
                    itself, not by the problem you are trying to resolve. Therefore, you have to spend some time
                    figuring out what is going on. Moreover, one of the worst test results are if the error is random.
                    This is because the team cannot trust the reliability of the tests which could lead to a lack of
                    confidence in applying <i>TDD/BDD</i>.
                    Now, we are conscious of this potential problem, what strategy can we employ to resolve this
                    situation? <b>TestPyramid</b>.
                </p>
            </section>
            <section>
                <h2>TestPyramid</h2>

                <p>
                    In summary this concept <b>inverts the cone</b>. Your <em>unit tests</em> should cover all the
                    business rules of the
                    system. We should make sure we are using the same language, in this case a <em>unit test</em>:
                </p>

                <blockquote>
                    A <em>unit test</em> is a test that <b>‘runs in isolation’</b> from the other tests and does <b>not
                    integrate with
                    ‘shared fixtures’</b> (e.g. file, database).
                </blockquote>

                <p>
                    If your write your <b>user stories</b> as a <em>unit test</em>, you have a powerful test suite which
                    enables you to
                    continually modify the code and subsequently run your tests. Using this approach, you can write your
                    <b>test outside-in</b> focusing on the <i>behaviour of the system</i> and <i>avoiding the
                    verification of the
                    implementation details</i>. Does this mean the whole tests should be <em>unit tests</em>?
                    Effectively we
                    should
                    have <i>different types of tests depending on the objective</i>. However, as the following diagram
                    demonstrates, the difference should be focused on the objective of code coverage that should be
                    achieved:
                </p>
                <figure class="post_image"><img alt="" src="../img/TestPyramid.png"></figure>
                <p>
                    There is a notion that states <i>you should not base your software design on tests needs</i>. For
                    example,
                    you should not expose internal details to validation, in this case it is obvious why you should not
                    do it: <i>you are breaking the encapsulation principle</i>. However, we have to bear in mind that
                    one of
                    the <b>quality attributes</b> that the software has to achieve is that <b>it should be testable</b>.
                    Moreover, <i>the
                    more testable a system, the more decoupled it is</i>. Therefore, when we design software we should
                    aim
                    for <b>testable architectures</b>.
                </p>

                <p>
                    The talk <a href="http://vimeo.com/68375232">TDD: where did it all go wrong</a> by <a
                        href="http://twitter.com/icooper">Ian Cooper</a>,
                    explores this topic. As <a
                        href="http://twitter.com/icooper">Ian Cooper</a> explains,
                    <em>Hexagonal architecture</em> is one of the architectures to achieve the ideal <em>TestPyramid</em>.
                </p>
            </section>
            <section>
                <h2>What is Hexagonal architecture?</h2>

                <p>
                    It was defined by <a href="http://twitter.com/totheralistair">Alistair Cockburn</a> as follows:
                </p>
                <blockquote>
                    Create your application to work without either a UI or a database so you can run automated
                    regression-tests against the application, work when the database becomes unavailable, and link
                    applications together without any user involvement.
                    <cite><a href="http://twitter.com/totheralistair">Alistair Cockburn</a></cite>
                </blockquote>
                <figure class="post_image"><img alt="" src="../img/ports-and-adapters.png"></figure>
                <p>
                    Basically, you define a <b>core</b> which implements the <b>user stories/use cases</b> of the
                    application. This
                    core <i>provides interfaces to plug specific technology/frameworks</i> that provide access to <i>inputs and
                    outputs as well as defining the boundaries</i> of your system. In this architecture, <i>the business logic
                    does not depend on external modules</i>. In contrast, the external modules should depend on the business
                    logic. Therefore your <b>core logic is decoupled from the infrastructure</b> making it easier to test
                    independently from external dependencies (shared fixtures).
                </p>
                <figure class="post_image"><img alt="" src="../img/High%20Level%20Clean%20Architecture.png"></figure>
                <p>
                    <em>Dependency inversion</em> is the principle behind this architecture. The diagram above illustrates this
                    perfectly as it shows that the <b>dependencies are inverted</b>.
                </p>

                <p>
                    This approach contrasts with traditional <em>Layered Architecture</em> that provides you with the flexibility
                    to change your database engine. But in my experience this is rarely the case in the real world. A
                    more common situation is that you want to update/change the library/framework that gives you access
                    to the database or to use the new <i>‘revolutionary’ framework</i>. With <em>Layered Architecture</em> this
                    situation is harder because your business logic module depends on the database module. In contrast,
                    <em>Hexagonal Architecture</em> offers you the <i>flexibility to change technologies/frameworks without
                    affecting the application’s core</i>.

                </p>
            </section>
            <footer>
                <p>
                    In the next post I will give an example to illustrate a way of implementing and defining <em>Hexagonal
                    Architecture</em>. I will also discuss the remaining components of the architecture.
                </p>
                <script src="//platform.linkedin.com/in.js" type="text/javascript">
                    lang: en_US
                </script>
                <script type="IN/Share" data-counter="right"></script>
                <!-- Place this tag in your head or just before your close body tag. -->
                <script src="https://apis.google.com/js/platform.js" async defer></script>
                <!-- Place this tag where you want the share button to render. -->
                <div class="g-plus" data-action="share" data-annotation="bubble"></div>
                <a href="https://twitter.com/share" class="twitter-share-button" data-via="BeniVF">Tweet</a>
                <script>!function (d, s, id) {
                    var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
                    if (!d.getElementById(id)) {
                        js = d.createElement(s);
                        js.id = id;
                        js.src = p + '://platform.twitter.com/widgets.js';
                        fjs.parentNode.insertBefore(js, fjs);
                    }
                }(document, 'script', 'twitter-wjs');</script>
            </footer>
        </article>


    </div>
    <!-- #main -->
</div>
<!-- #main-container -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="../js/vendor/jquery-1.11.1.min.js"><\/script>')</script>

<script src="../js/main.js"></script>

<!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-57264654-1', 'auto');
    ga('send', 'turn-ice-cream-cone-into-pyramid');

</script>
</body>
</html>
